#!/usr/bin/env python
#
# python-netsnmpagent example agent with threading
#
# Copyright (c) 2013 Pieter Hollants <pieter@hollants.com>
# Licensed under the GNU Public License (GPL) version 3
#

#
# simple_agent.py demonstrates registering the various SNMP object types quite
# nicely but uses an inferior control flow logic: the main loop blocks in
# net-snmp's check_and_process() call until some event happens (eg. SNMP
# requests need processing). Only then will data be updated, not inbetween. And
# on the other hand, SNMP requests can not be handled while data is being
# updated, which might take longer periods of time.
#
# This example agent uses a more real life-suitable approach by outsourcing the
# data update process into a separate thread that gets woken up through an
# SIGALRM handler at an configurable interval. This does only ensure periodic
# data updates, it also makes sure that SNMP requests will always be replied to
# in time.
#
# Note that this implementation does not address possible locking issues: if
# a SNMP client's requests are processed while the data update thread is in the
# midst of refreshing the SNMP objects, the client might receive partially
# inconsistent data. 
#
# Use the included script run_threading_agent.sh to test this example.
#
# Alternatively, see the comment block in the head of simple_agent.py for
# adaptable instructions how to run this example against a system-wide snmpd
# instance.
#

import sys, os, signal, time
import optparse, threading, subprocess


# Defining files necessary for systemd monitoring
# File that contains units that do not need to be monitored
not_monitored_units = "./not_monitored_units"

# File that contains units that should not be running
to_be_down_units = "./to_be_down_units"


# File that contains units that should be enabled
enabled_units = "./enabled_units"




# Make sure we use the local copy, not a system-wide one
sys.path.insert(0, os.path.dirname(os.getcwd()))
import netsnmpagent

prgname = sys.argv[0]

# Process command line arguments
parser = optparse.OptionParser()
parser.add_option(
	"-i",
	"--interval",
	dest="interval",
	help="Set interval in seconds between data updates",
	default=30
)
parser.add_option(
	"-m",
	"--mastersocket",
	dest="mastersocket",
	help="Sets the transport specification for the master agent's AgentX socket",
	default="/var/run/agentx/master"
)
parser.add_option(
	"-p",
	"--persistencedir",
	dest="persistencedir",
	help="Sets the path to the persistence directory",
	default="/var/lib/net-snmp"
)
(options, args) = parser.parse_args()

headerlogged = 0
def LogMsg(msg):
	""" Writes a formatted log message with a timestamp to stdout. """

	global headerlogged

	if headerlogged == 0:
		print "{0:<8} {1:<90} {2}".format(
			"Time",
			"MainThread",
			"UpdateSNMPObjsThread"
		)
		print "{0:-^120}".format("-")
		headerlogged = 1

	threadname = threading.currentThread().name

	funcname = sys._getframe(1).f_code.co_name
	if funcname == "<module>":
		funcname = "Main code path"
	elif funcname == "LogNetSnmpMsg":
		funcname = "net-snmp code"
	else:
		funcname = "{0}()".format(funcname)

	if threadname == "MainThread":
		logmsg = "{0} {1:<112.112}".format(
			time.strftime("%T", time.localtime(time.time())),
			"{0}: {1}".format(funcname, msg)
		)
	else:
		logmsg = "{0} {1:>112.112}".format(
			time.strftime("%T", time.localtime(time.time())),
			"{0}: {1}".format(funcname, msg)
		)
	print logmsg

def LogNetSnmpMsg(priority, msg):
	""" Log handler for log messages generated by net-snmp code. """

	LogMsg("[{0}] {1}.".format(priority, msg))

# Create an instance of the netsnmpAgent class
try:
	agent = netsnmpagent.netsnmpAgent(
		AgentName      = "systemdAgent",
		MasterSocket   = options.mastersocket,
		PersistenceDir = options.persistencedir,
		MIBFiles       = [ os.path.abspath(os.path.dirname(sys.argv[0])) +
		                   "/NETWORK-SERVICES-MIB.txt" ],
		LogHandler     = LogNetSnmpMsg,
	)
except netsnmpagent.netsnmpAgentException as e:
	print "{0}: {1}".format(prgname, e)
	sys.exit(1)

# Creating the table
applTable = agent.Table(
	oidstr = "NETWORK-SERVICES-MIB::applTable",
	indexes = [
                agent.Integer32()
	],
	columns = [
		(2, agent.OctetString("")),
		(6, agent.Integer32())
	]
)



def UpdateSNMPObjs():
	""" Function that does the actual data update. """

	global applTable

	LogMsg("Beginning data update.")
	data = ""

	# Obtain the data by calling an external command. We don't use
	# subprocess.check_output() here for compatibility with Python versions
	# older than 2.7.


	# retrieving all units, not counting the ones starting with "-" as they cannot be queried with systemctl commands
	all_units_regex = subprocess.Popen("systemctl list-unit-files | head -n -2 | tail -n +2 | grep -v '^-' | awk '{print $1}'", shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
	all_units = all_units_regex.communicate()[0].splitlines()


	
	# removing units that do not need to be monitored (i.e. present in the not_monitored_units file)
	# first adding units present in the file in a list, with stripping out '\n'
	not_monitored_units_list = [i.rstrip('\n') for i in open(not_monitored_units)]
	
	# removing possible spaces from list items
	not_monitored_units_list = [i.strip(' ') for i in not_monitored_units_list]
		
	# then, if the list contains units present in the all_units list, remove the units from the all_units list
	corrected_not_monitored_units_list = set(not_monitored_units_list) & set(all_units)
	if len(corrected_not_monitored_units_list) != 0:
        	for units in corrected_not_monitored_units_list:
                	all_units.remove(units)
	

	# retrieving the status of the units
	units_state = []
	for units in all_units:
        	units_state_cmd = subprocess.Popen("systemctl is-active " + units, shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        	units_state.append(units_state_cmd.communicate()[0])
	# removing '\n' from the state
	units_state = [i.strip('\n') for i in units_state]	
	
	# Creating a list that contains units that must not be running (i.e. units that are present in the to_be_down_units file)
	# Stripping out the "\n"
	down_units = [i.rstrip('\n') for i in open(to_be_down_units)]
	# Stripping out accidental spaces
        down_units = [i.strip(' ') for i in down_units]

	# Creating a list where the items from  down_units are indeed real items present in all_units list
	down_units_list = set(down_units) & set(all_units)
	
	# creating a dictionary with units as keys, their state as values
	units_state_dic = dict(zip(all_units, units_state))
	
	# Changing the state of a unit present in the down_units_list so the monitoring system shows OK for this unit that must be down or not OK if active 
	if len(down_units_list) != 0:	
		for units in down_units_list:
			if units_state_dic[units] == "inactive":
				units_state_dic[units] = "active"
			elif units_state_dic[units] == "active":
                        	units_state_dic[units] = "inactive"


	 # retrieving information whether a unit is started at boot time
        units_at_boot = []
        for units in all_units:
                units_at_boot_cmd = subprocess.Popen("systemctl is-enabled " + units, shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                units_at_boot.append(units_at_boot_cmd.communicate()[0])

        units_at_boot = [x.strip('\n') for x in units_at_boot]

	# creating a dictionary with units as keys, whether they are enabled or not as values
	units_at_boot_dic = dict(zip(all_units, units_at_boot))
        
	# creating a list that contains units that should be enabled (i.e. units that are present in the enabled_units file)
	enabled_units_list = [i.rstrip('\n') for i in open(enabled_units)]
	enabled_units_list = [i.strip(' ') for i in enabled_units_list]	

	# then, if the list contains units present in the all_units list, make sure they are indeed enabled and change their state from the agent point of view if otherwise
	corrected_enabled_units_list = set(enabled_units_list) & set(all_units)
	if len(corrected_enabled_units_list) != 0:
                for units in corrected_enabled_units_list:
                	if units_at_boot_dic[units] != "enabled":
                        	units_state_dic[units] = "inactive"


	# Clearing the applTable to allow new data insertion
	applTable.clear()
	
	# Creating rows and cells
	for units in all_units:
		index = all_units.index(units) + 1
		tableRow = applTable.addRow([agent.Integer32(index)])
		tableRow.setRowCell(2, agent.OctetString(str(units)))
		if units_state_dic[units] == "active":
			tableRow.setRowCell(6, agent.Integer32(1))
		elif units_state_dic[units] == "unknown":
                        tableRow.setRowCell(6, agent.Integer32(3))
		else:
			tableRow.setRowCell(6, agent.Integer32(2))			
			

	LogMsg("Data update done, exiting thread.")

def UpdateSNMPObjsAsync():
	""" Starts UpdateSNMPObjs() in a separate thread. """

	# UpdateSNMPObjs() will be executed in a separate thread so that the main
	# thread can continue looping and processing SNMP requests while the data
	# update is still in progress. However we'll make sure only one update
	# thread is run at any time, even if the data update interval has been set
	# too low.
	if threading.active_count() == 1:
		LogMsg("Creating thread for UpdateSNMPObjs().")
		t = threading.Thread(target=UpdateSNMPObjs, name="UpdateSNMPObjsThread")
		t.daemon = True
		t.start()
	else:
		LogMsg("Data update still active, data update interval too low?")

# Start the agent (eg. connect to the master agent).
try:
	agent.start()
except netsnmpagent.netsnmpAgentException as e:
	LogMsg("{0}: {1}".format(prgname, e))
	sys.exit(1)

# Trigger initial data update.
LogMsg("Doing initial call to UpdateSNMPObjsAsync().")
UpdateSNMPObjsAsync()


# Install a signal handler that terminates our threading agent when CTRL-C is
# pressed or a KILL signal is received
def TermHandler(signum, frame):
	global loop
	loop = False
signal.signal(signal.SIGINT, TermHandler)
signal.signal(signal.SIGTERM, TermHandler)

# Define a signal handler that takes care of updating the data periodically
def AlarmHandler(signum, frame):
	global loop, timer_triggered

	LogMsg("Got triggered by SIGALRM.")

	if loop:
		timer_triggered = True

		UpdateSNMPObjsAsync()

		signal.signal(signal.SIGALRM, AlarmHandler)
		signal.setitimer(signal.ITIMER_REAL, float(options.interval))
msg = "Installing SIGALRM handler triggered every {0} seconds."
msg = msg.format(options.interval)
LogMsg(msg)
signal.signal(signal.SIGALRM, AlarmHandler)
signal.setitimer(signal.ITIMER_REAL, float(options.interval))

# The threading agent's main loop. We loop endlessly until our signal
# handler above changes the "loop" variable.
LogMsg("Now serving SNMP requests, press ^C to terminate.")

loop = True
while loop:
	# Block until something happened (signal arrived, SNMP packets processed)
	timer_triggered = False
	res = agent.check_and_process()
	if res == -1 and not timer_triggered and loop:
		loop = False
		LogMsg("Error {0} in SNMP packet processing!".format(res))
	elif loop and timer_triggered:
		LogMsg("net-snmp's check_and_process() returned due to SIGALRM (res={0}), doing another loop.".format(res))
	elif loop:
		LogMsg("net-snmp's check_and_process() returned (res={0}), doing another loop.".format(res))

LogMsg("Terminating.")
agent.shutdown()
